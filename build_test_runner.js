var peg             = require('./peg.js'),
    dbg             = require('./debug.js'),
    bar             = require('./progress.js'),
    fs              = require('fs'),
    path            = require('path'),
    str             = require('string'),
    nl              = '\n',
    flags           = {},
    testData        = {};

exports.build = function(readStreamName, filename, callback){
  testData = resetData();
  parseUnitTests(readStreamName);
  prepareTests(readStreamName, filename);
  callback();
  return testData.includes;
};

function resetData(){
  return {tests: [], lines: [],
          includes: [], buf: '',
          count: 0, voidLn: 0, lineNum: 0};
}

function writeTestData(writeBuf, filename){
  writeBuf = writeIncludes(writeBuf);
  writeBuf = writeDeclarations(writeBuf);
  writeBuf = writeMain(writeBuf, filename);
  return writeTests(writeBuf);
}

function prepareTests(readStreamName, filename){
  var writeBuf = '';
  bar.update('build');
  writeBuf = writeBufMacro(writeBuf);
  writeBuf = writeTestData(writeBuf, filename);
  writeBuf = writeUnityEnd(writeBuf, filename);
  fs.writeFileSync(filename, writeBuf.toString('utf-8'));
}

function isOpenBracket(line){
  return (line.indexOf('{') > -1);
}

function voidFound(line){
  testData.buf += ' ' + line;
  dbg.voidFound(testData.buf);
  if(isOpenBracket(line)){
    flags.voidFound = false;
    flags.scan = true;
  }
}

function testLineNum(parsed){
  return parsed[3][0] + parsed[3][1].join('');
}

function parseTest(){
  return peg.parse(testData.buf, 'testParser');
}

function parseInclude(line){
  return peg.parse(line.trim(), 'includeParser');
}

function processTest(parsed){
  if( ! parsed) return;
  saveTest(testData.voidLn, testLineNum(parsed));
  testData.voidLn = 0;
  testData.buf = '',
  testData.count += 1;
  dbg.count(testData.count);
}

function parseLine(){
  dbg.scan(testData.buf);
  processTest( parseTest());
  flags.scan = false;
  testData.buf = '';
}

function isVoid(line){
  if( ! flags.voidFound) {
    return line.indexOf('void') > -1;
  }
  return false;
}

function isInclude(line){
  return line.indexOf('#include') > -1;
}

function onLine(line) {
  testData.lineNum += 1;
  if(isVoid(line)){
    flags.voidFound = true;
    testData.voidLn = testData.lineNum;
  }

  if(flags.voidFound)
  {
    voidFound(line);
  }
  if(flags.scan)
  {
    parseLine();
  }
  if(isInclude(line)){
    var include = parseInclude(line);
    saveInclude(include, headerFile(include));
  }
}

function headerFile(incs){
  return incs[3][0] + incs[3][2].join('') + incs[3][4];
}

var parseUnitTests = function(readStreamName) {
  var inData = fs.readFileSync(readStreamName).toString().split("\n");

  inData.map(function(v){
    onLine(v);
  });
};

function writeUnityEnd(writeBuf, filename){
  var complete = false;
  writeBuf += (writeTitle('End Test Run') + nl);
  writeBuf += ('  return (UnityEnd());' + nl + '}' + nl +
                    (writeTitle('End of ' + path.basename(filename))));
  return writeBuf;
};

function saveInclude(include, filename) {
  if( ! include) return;
  testData.includes.push(filename);
}

function writeIncludes(writeBuf) {
  var inc = testData.includes.filter(function(item, pos, self) {
    return self.indexOf(item) == pos;});
  writeBuf += (writeTitle('Detected Include Files') + nl);
  inc.map(function(i){
    writeBuf += ('#include ' + i + nl);
  });
  return writeBuf;
}

function writeTests(writeBuf){
  writeBuf += (writeTitle('Tests') + nl);
  for(var count = 0; count < testData.tests.length; count++){
    writeBuf += '  RUN_TEST(' + testData.tests[count] + ', ' + (testData.lines[count].toString()) + ');\n';
  }
  return writeBuf;
}

function saveTest(line, test){
  testData.tests.push(test);
  testData.lines.push(line);
}

function writeTitle(title){
  var sp = '  ', pad = '=',
      fTitle = str(sp + title + sp).pad(50, pad);
  return nl + '/*  ' + fTitle + '  */' + nl;
}

function writeBufMacro(writeBuf){
  writeBuf +=
  (writeTitle('AUTOGENERATED FILE. DO NOT EDIT!')          +
   writeTitle('Runner Used To Run Each Test')         + nl +
   '#define RUN_TEST(TestFunc, TestLineNum) \\'       + nl +
   '{ \\'                                             + nl +
   '  Unity.CurrentTestName = #TestFunc; \\'          + nl +
   '  Unity.CurrentTestLineNumber = TestLineNum; \\'  + nl +
   '  Unity.NumberOfTests++; \\'                      + nl +
   '  if (TEST_PROTECT()) \\'                         + nl +
   '  { \\'                                           + nl +
   '    setUp(); \\'                                  + nl +
   '    TestFunc(); \\'                               + nl +
   '  } \\'                                           + nl +
   '  if (TEST_PROTECT() && ! TEST_IS_IGNORED) \\'    + nl +
   '  { \\'                                           + nl +
   '    tearDown(); \\'                               + nl +
   '  } \\'                                           + nl +
   '  UnityConcludeTest(); \\'                        + nl +
   '}'                                                + nl );
  return writeBuf;
};

function sleep(time, callback) {
    var stop = new Date().getTime();
    while(new Date().getTime() < stop + time) {
        ;
    }
    callback();
}

function writeDeclarations(writeBuf){
  writeBuf += (writeTitle('Declarations') + nl);
  writeBuf += 'void setUp(void);\n';
  writeBuf += 'void tearDown(void);\n';
  testData.tests.map(function(data){
    writeBuf += 'void ' + data + '(void);' + nl;
  });
  return writeBuf;
}

function writeMain(writeBuf, filename) {
  writeBuf +=
  (writeTitle('Test Reset Option')      + nl +
   'void resetTest(void);'              + nl +
   'void resetTest(void)'               + nl +
   '{'                                  + nl +
   '  tearDown();'                      + nl +
   '  setUp();'                         + nl +
   '}'                                  + nl +
   writeTitle('main()')                 + nl +
   'int main(void)'                     + nl +
   '{'                                  + nl +
   '  UnityBegin("' +
   path.basename(filename) + '");'    + nl );
  return writeBuf;
}
