var peg             = require('./peg.js'),
    dbg             = require('./debug.js'),
    fs              = require('fs'),
    path            = require('path'),
    str             = require('string'),
    clc             = require('cli-color'),
    testData        = {tests: [], lines: [], includes: []},
    flags           = { },
    nl              = '\n',
    runnerName      = '',
    buffer          = '',
    testCount       = 0,
    voidLine        = 0,
    lineNum         = 0,
    writeBuf        = '';
    close           = false;

exports.build = function(readStreamName, filename){
  testData    = {tests: [], lines: [], includes: []},
  writeBuf    = '';
    testCount = 0,
    voidLine  = 0,
    lineNum   = 0,
  runnerName = filename;
  runState(readStreamName);
};

function voidFound(line){
  buffer += ' ' + line;
  dbg.voidFound(buffer);
  if(line.indexOf('{') > -1){
    flags.voidFound = false;
    flags.scan = true;
  }
}

function parseTest(){
  dbg.scan(buffer);
  var tsts = peg.parse(buffer, 'testParser');
  if(tsts){
    buffer = '';
    testCount += 1;
    saveTest(voidLine, tsts[3][0] + tsts[3][1].join(''));
    voidLine = 0;
    dbg.count(testCount);
  }
  flags.scan = false;
  buffer = '';
}

function isVoid(line){
  if( ! flags.voidFound) {
    return line.indexOf('void') > -1;
  }
  return false;
}

function isInclude(line){
  return line.indexOf('#include') > -1;
}

function onLine(line) {
  lineNum += 1;
  if(isVoid(line)){
    flags.voidFound = true;
    voidLine = lineNum;
  }

  if(flags.voidFound)
  {
    voidFound(line);
  }
  if(flags.scan)
  {
    parseTest();
  }
  if(isInclude(line)){
    var incs = peg.parse(line.trim(), 'includeParser');
    if(incs){
      saveInclude(incs[3][0] + incs[3][2].join('') + incs[3][4]);
    }
  }
}

var parseUnitTests = function(readStreamName) {
  var inData = fs.readFileSync(readStreamName).toString().split("\n");

  for(count = 0; count < inData.length; count++)
  {
    onLine(inData[count]);
  }
};

function writeUnityEnd(writeBuf){
  var complete = false;
  writeBuf += (writeTitle('End Test Run') + nl);
  writeBuf += ('  return (UnityEnd());' + nl + '}' + nl +
                    (writeTitle('End of ' + path.basename(runnerName))));
  return writeBuf;
};

function saveInclude(filename) {
  testData.includes.push('#include ' + filename);
}

function writeIncludes(writeBuf) {
  var inc = testData.includes.filter(function(item, pos, self) {
    return self.indexOf(item) == pos;});
  writeBuf += (writeTitle('Detected Include Files') + nl);
  for(var count = 0; count < inc.length; count++){
    writeBuf += (inc[count] + nl);
  }
  return writeBuf;
}

function writeTests(writeBuf){
  writeBuf += (writeTitle('Tests') + nl);
  for(var count = 0; count < testData.tests.length; count++){
    writeBuf += '  RUN_TEST(' + testData.tests[count] + ', ' + (testData.lines[count].toString()) + ');\n';
  }
  return writeBuf;
}

function saveTest(line, test) {
  testData.tests.push(test);
  testData.lines.push(line);
}

function writeTitle(title){
  var sp = '  ', pad = '=',
      fTitle = str(sp + title + sp).pad(50, pad);
  return nl + '/*  ' + fTitle + '  */' + nl;
}

function writeBufMacro(writeBuf){
  writeBuf +=
  (writeTitle('AUTOGENERATED FILE. DO NOT EDIT!')          +
   writeTitle('Runner Used To Run Each Test')         + nl +
   '#define RUN_TEST(TestFunc, TestLineNum) \\'       + nl +
   '{ \\'                                             + nl +
   '  Unity.CurrentTestName = #TestFunc; \\'          + nl +
   '  Unity.CurrentTestLineNumber = TestLineNum; \\'  + nl +
   '  Unity.NumberOfTests++; \\'                      + nl +
   '  if (TEST_PROTECT()) \\'                         + nl +
   '  { \\'                                           + nl +
   '    setUp(); \\'                                  + nl +
   '    TestFunc(); \\'                               + nl +
   '  } \\'                                           + nl +
   '  if (TEST_PROTECT() && ! TEST_IS_IGNORED) \\'    + nl +
   '  { \\'                                           + nl +
   '    tearDown(); \\'                               + nl +
   '  } \\'                                           + nl +
   '  UnityConcludeTest(); \\'                        + nl +
   '}'                                                + nl );
  return writeBuf;
};

function sleep(time, callback) {
    var stop = new Date().getTime();
    while(new Date().getTime() < stop + time) {
        ;
    }
    callback();
}

function writeDeclarations(writeBuf){
//extern void setUp(void);
//extern void tearDown(void);
//extern void testNotEqualDoubleArraysInf (void );

  writeBuf += (writeTitle('Declarations') + nl);
  writeBuf +=    'void setUp(void);\n';
  writeBuf +=    'void tearDown(void);\n';

  for(var count = 0; count < testData.tests.length; count++){
    writeBuf += 'void ' + (testData.tests[count] + '(void);' + nl);
  }
  return writeBuf;
}

function writeMain(writeBuf) {
  writeBuf +=
  (writeTitle('Test Reset Option')      + nl +
   'void resetTest(void);'              + nl +
   'void resetTest(void)'               + nl +
   '{'                                  + nl +
   '  tearDown();'                      + nl +
   '  setUp();'                         + nl +
   '}'                                  + nl +
   writeTitle('main()')                 + nl +
   'int main(void)'                     + nl +
   '{'                                  + nl +
   '  UnityBegin("' +
   path.basename(runnerName) + '");'    + nl );
  return writeBuf;
}

function runState(readStreamName){
//  var stop = new Date().getTime();
  var states = ['parse unit tests', 'write runner wait', 'write run macro',
                'write includes', 'write declarations', 'write main',
                'write tests', 'write unity end', 'write to file', 'wait'];
  var state = 0;
  while(state < states.length)
  {
    switch(states[state]) {

    case 'parse unit tests':
      parseUnitTests(readStreamName);

      state += 1;
      break;

    case 'write runner wait':
      state +=1;
      break;

    case 'write run macro':
      writeBuf = writeBufMacro(writeBuf);
      state += 1;
      break;

    case 'write includes':
      writeBuf = writeIncludes(writeBuf);
      state += 1;
      break;

    case 'write declarations':
      writeBuf = writeDeclarations(writeBuf);
      state += 1;
      break;

    case 'write main':
      writeBuf = writeMain(writeBuf);
      state += 1;
      break;

    case 'write tests':
      writeBuf = writeTests(writeBuf);
      state += 1;
      break;

    case 'write unity end':
      writeBuf = writeUnityEnd(writeBuf);
      state += 1;
      break;

    case 'write to file':
      fs.writeFileSync(runnerName, writeBuf.toString('utf-8'));
      state += 1;
      break;

    case 'wait':
      state += 1;
      break;

    default:
      console.log(clc.red('in default!!'));
    }
  }
}
